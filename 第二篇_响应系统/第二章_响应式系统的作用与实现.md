# 第二章 响应式系统的作用与实现

### 4.1 响应式数据与副作用函数 

        //全局变量
        let val = 1
        function effect() {
            val = 2 //修改全局变量
        }

        副作用就是值会产生副作用的函数，如上面代码中，val是一个全局变量，有可能会在多个地方用到，
    effect函数中修改了val，那么其他引用到val的地方可能就会直接或间接收到影响。影响到其他地方
    就是effect产生了副作用。

        响应式数据就是当数据发生变化后，副作用函数自动会重新执行。

        const obj = {text: 'hello world'}
        function effect() {
            document.body.innerText = obj.text
        }
        
        如上面的代码，如果obj.text的值发生了改变，那么副作用函数effect自动会重新执行，obj就被
    称为响应式数据。

### 4.2 响应式数据的基本实现

        变成响应式数据，可以有两个步骤：
        
        1. 当副作用函数(上文的effect())执行时，会触发副作用内数据的读取操作；
        2. 当修改数据时，会触发数据的设置操作

        可以看出想要实现响应式需要先拦截对象的读取和设置操作，可以使用一个“桶”当容器，将副作用函数存储
    起来。

        读取操作：

        执行副作用函数(effect())  ---> 触发读取操作 ---> 将副作用函数存储容器“桶”中

        设置操作：

        容器“桶” ---> 触发设置操作 ---> 拿出并执行副作用函数(effect())

        可以看出读取操作就是将副作用函数存储到容器中，设置操作就是将副作用函数从容器中拿出来执行。

        在Vue2中使用的是Object.defineProperty函数对对象进行拦截，到Vue3时使用了ES6中的代理对象
    Proxy来实现,如下时一个简单的代理实现对对象的拦截：

        // 存储副作用函数的桶
        const bucket = new Set()
        // 原始数据
        const data = { text: 'hello world' }
        // 对原始数据的代理
        const obj = new Proxy(data, {
            // 拦截读取操作
            get(target, key) {
                // 将副作用函数添加到存储到存储副作用函数的桶中
                bucket.add(effect)
                // 返回属性值
                return target[key]
            },
            // 拦截设置操作
            set(target, key, newVal) {
                // 设置属性值
                target[key] = newVal
                // 把副作用函数从桶中取出并执行
                bucket.forEach(fn =>fn())
                //返回 true 代表操作成功
                return true
            }
        })

        //副作用函数
        function effect() {
            document.body.innerHTML = obj.text
        }

        //执行副作用函数触发读取
        effect()
        //一秒后修改响应式数据
        setTimeout(() => {
            obj.text = 'hello vue3'
        },1000)

        上面的代码就可以实现一个简单的对象拦截来实现响应式数据。
