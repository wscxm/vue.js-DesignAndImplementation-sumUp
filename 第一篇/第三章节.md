Vue.js3的设计思路

3.1 声明式地描述UI

        Vue.js3是一个声明式的框架，也就是使用声明式地描述UI的，设计声明式框架前先了解下编写前端
    页面设计哪些内容：

        1. DOM元素： 例如div标签、a标签等元素标签。
        2. 属性： 例如a标签上的href、标签上的id、class等。
        3. 事件： 例如click、keydown等。
        4. 元素的层级结构： DOM树的层级结构、既有子节点又有父节点。

        Vue.js3描述上述内容的方案是：

        1. 使用与HTML标签一致的方式描述DOM元素：如描述div标签直接<div></div>。
        2. 使用与HTML标签一致的方式描述标签的属性： 如div标签中的id<div id='div'></div>。
        3. 使用v-bind或:描述动态绑定属性： 如div标签中的动态id<div :id='div'></div>或
            <div v-bind:id='div'></div>。
        4. 使用v-on或@来描述事件：例如描述点击事件<div @click='handler'></div>或
            <div v-on:click='handler'></div>。
        5. 使用与HTML标签一致的方式描述层级结构： 如div包含一个span子节点<div><span></span></div>。

        从上述中知道在Vue中DOM元素、属性、事件等都有相应的描述方式，不需要用户手写命令式代码，这
    就是声明式地描述UI

        除了使用上述地模板(组件中的<template>写法)来声明式地描述UI外，还可以使用JS对象描述，将
    <div v-on:click='handler'><span></span></div>用JS对象描述如：

        1. const title = {
        2.     // 标签名称
        3.     tag: 'h1',
        4.     // 标签属性
        5.     props: {
        6.         onClick: handler
        7.     },
        8.     // 子节点
        9.     children: {
        10.        {tag: 'span'}
        11.    }
        12. }

        使用JS对象描述UI的好处就是更灵活，假如描述一个h1-h6的标标签，用JS对象描述如：

        1. //h标签的等级
        2. let level = 3
        3. const title = {
        4.     tag: `h${level}`
        5. }

        使用JS对象描述可以更改level来改变h标签。

        使用模板描述就需要依次手HTML代码如：
        1. <h1 v-if="level === 1"></h1>
        2. <h2 v-else-if="level === 2"></h2>
        3. <h3 v-else-if="level === 3"></h3>
        4. <h4 v-else-if="level === 4"></h4>
        5. <h5 v-else-if="level === 5"></h5>
        6. <h6 v-else-if="level === 6"></h6>

        可以看到模板描述远不如JS对象描述灵活，使用JS对象描述，就是所谓的虚拟DOM，也就是因为虚拟
    DOM的灵活性，Vue除了支持模板描述UI外，同时也支持虚拟DOM描述UI。

        平时组件中手写的渲染函数就是使用虚拟DOM描述UI，如下代码：

        1. import { h } from 'vue'
        2. export default {
        3.     render() {
        4.         return h('h1', {onClick: handler}) //虚拟DOM
        5.     }
        6. }

        上述的h函数是辅助创建虚拟DOM的一个工具函数，调用后会返回一个对象，这个对象就是虚拟DOM，
    上述的render函数也成为渲染函数，在Vue中也有render函数，Vue根据函数返回的值拿到虚拟DOM，然
    后将组件内容渲染出来。

3.2 初识渲染器

        虚拟DOM的本质就是一个使用JS对象描述的真实DOM结构，虚拟DOM变成真实的DOM则需要通过渲染器。

        渲染器的作用就是将虚拟DOM渲染为真实DOM，过程如：

        1. h('h1', {onClick: handler})(虚拟DOM) ---> 渲染器 ---> 真实DOM

        实现一个简易的渲染器，如：
        1. function renderer (vnode, container) {
        2.     // 使用vonde.tag作为标签名创建元素
        3.     const el = document.createElement(vnode.tag)
        4.     // 循环遍历vonde.props，将属性、事件添加到标签元素中
        5.     for (const key in vnode.props) {
        6.         //判断是否为事件
        7.         if(/^on/.test(key)) {
        8.             el.addEventListener(
        9.                 // 事件名称，如onClick --->click
        10.                 key.substring(2).toLowerCase(),
        11.                 // 处理事件
        12.                 vnode.props[key]
        13.             )
        14.         }
        15.     }
        16.     //处理children
        17.     if(typeof vnode.children === 'string') {
        18.         // 如果children是字符串，说明它是元素的文本节点
        19.         el.appendChild(document.createTextNode(vnode.children))
        20.     }else if(Array.isArray(vnode.children)){
        30.         // 如果是数组，说明有子节点，递归调用函数渲染子节点,使用el作为挂载点
        31.         vnode.children.forEach(child => renderer(child, el));        
        32.     }
        33.     //最后将元素添加到挂载节点中
        34.     container.appendChild(el)
        35. }

        再构造一个虚拟DOM：

        1. const vnode = {
        2.     tag: 'div',
        3.     props: {
        4.         onclick: () =>alert('hello')
        5.     },
        6.     children: 'click me'
        7. }
        8. // 调用renderer函数
        9. renderer(vnode, document.body) //将body作为挂载点

        一个简易的渲染器renderer的实现思路，总体分为三步：

        1. 创建元素：将tag作为元素名创建元素
        2. 给元素添加事件或属性：遍历props再进行判断，如果on开头的说明是事件，使用addEventListener
            绑定到元素中，注意将'on'截去再用toLowerCase转化为小写字符串。
        3. 处理处理children：如果是字符串，直接新创建文本插入标签元素，如果是数组则循环递归调用
            renderer，注意将刚刚的标签元素当成挂载点。
        