第二章节 框架设计的核心要素

2.1 提升用户开发体验

        在设计框架时，合理的警告信息，可以让用户快速定位到问题的所在，进而进行修改，这可以给用
    户带来更好的开发体验。比如：

        1. createApp(App).mount('#not-exist')

        当创建一个Vue.js应用并试图挂载在不存在的DOM节点时，会收到一条警告，该信息会告诉我们挂
    载失败了，并且说明了Vue.js根据我们提供的选择器无法找到相应的DOM元素。这条信息可以让我们很
    快就定位到了问题所在。所以框架设计过程中，友好的警告信息至关重要。

        在Vue.js源码中，可以看到经常调用warn函数.如提醒找不到挂载的目标DOM元素警告:

        1. warn(`Failed to mount app: mount target selector "${container}" returned null`)

        对于warn函数来说，由于需要尽可能提供有用信息，因此需要收集当前发生错误的组件栈信息，源
    码中会有些复杂，但是最终就是调用了console.warn函数。

        在Vue3中除了必要的警告信息外，还有许多提升用户开发体验的点。例如，在控制台打印一个ref
    数据：

        1. const count = ref(0)
        2. console.log(count)

        在控制台中会输出一个RefImpl的对象，打印的数据非常不直观。在Vue3的源码中，可以搜索
    initCustomFormatter的函数，该函数可以在开发环境下初始化自定义formatter。以Chrome为例，
    可以打开DevTools的设置，勾选“Console”中的“Enable custom formatter”选项，然后刷新浏览器
    就可以看到控制台输出的内容变得非常直观。

2.2 控制框架代码的体积

        框架的大小也是衡量框架的标准之一。实现同样功能情况下，代码越少越好，这样体积就会越小，
    浏览器加载资源的时间也会越少。

        在Vue.js中提供越完善的警告提示就意味着代码量的增加，Vue3源码中，每个warn函数的调用都
    会配合__DEV__常量的检查。例如：

        1. if (__DEV__ && !res) {
            warn(`Failed to mount app: mount target selector "${container}" returned null`)
        }

        打印警告的信息前提就是__DEV__常量必须为true才行。

        Vue.js使用rollup.js对项目进行构建,这里的__DEV__是通过rollup.js的插件配置来预定义的
    其功能类似于webpack的DefinePlugin插件。

        Vue.js输出资源时会有两个版本，其中一个用于开发环境，如vue.globel.js,另一个版本用于生
    产环境,如vue.globel.prod.js。

        当Vue.js构建用于开发环境资源时,会把__DEV__常量预设为true,这时警告信息在开发环境肯定
    存在的。在生产环境时__DEV__常量预设为false,这样警告信息就不会执行,不会出现在最终产物中,
    在构建资源时会被移除。

        这样就可以做到在开发环境中提供友好的警告信息的同时,不会在增加生产环境代码的体积。

2.3 框架要做到良好的Tree-Shaking

        Tree-Shaking这个概念因rollup.js而普及，指的的是消除那些永远不会被执行的代码，也就是
    排除dead code。

        想要实现Tree-Shaking，必须要满足一个条件，即模块必须是ESM（ES Module），因为
    Tree-Shaking依赖ESM的静态结构。

        假设有两个文件input.js和utils.js，它们的内容是：
        
        //input.js
        1. import { foo } from 'utils.js' 
        2. foo()
        //utils.js
        3. export function foo(obj) {
        4.     obj && obj.foo
        5. }
        6. export function bar(obj) {
        7.     obj && obj.bar
        8. }

        npx rollup input.js -f esm -o bundle.js

        在input.js中引入utils.js的foo函数并执行，然后进行构建并输出一个bundle.js，可以看到他
    的内容：

        1. function foo(obj) {
        2.     obj && obj.foo
        3. }
        4. foo();

        可以看到,内容中并没有将bar函数打包进来，这说明Tree-Shaking起到了作用，将没有使用的
    bar函数作为dead code删除了。

        代码中的foo()是执行foo函数，它仅仅是读取了对象的值，在代码中并没有什么必要，但是
    rollup.js并没有将它当作dead code删除，这是因为涉及到了Tree-Shaking的第二个关键点--副作用
    如果一个函数的调用会产生副作用， 那么就不能将其移除。

        副作用就是当调用函数的时候会对外部产生影响，例如：修改了全局变量。

        上面的代码因为是读取对象的值，如果obj对象是通过Proxy创建的对象，当读取对象属性时，就会
    触发代理对象的get夹子(trap)，在get夹子中可能会产生副作用。但是到底会不会产生副作用啊，只有
    在代码真正运行时才知道，JS本身时动态语言，因此想要静态分析哪些代码是dead code很有难度，因
    此上面只是举例一个简单的例子。

        因为静态分析JS代码有困难，所以像rollup.js这类构建工具都会提供一个机制，让我们手动声明
    该代码没有副作用，可以放心进行Tree-Shaking，如：

         //input.js
        1. import { foo } from 'utils.js' 
        2. /*#__PURE__*/ foo()

        在代码前添加/*#__PURE__*/就是声明该代码不会产生副作用，可以进行Tree-Shaking。

        在Vue3的源码中就使用了大量的/*#__PURE__*/，例如：

        1. export const isHTMLtag = /*#__PURE__*/ makeMap(HTML_TAGS)

        在Vue3源码中多数都是在顶级函数(函数外的调用)中添加/*#__PURE__*/注解，因为函数内的调
    用如果该函数没被调用就不会产生副作用。例如：

        1. foo() //顶级调用
        2. function bar() {
            foo() //函数内调用
        }

        /*#__PURE__*/注解不止可以在rollup.js中使用，还可以在webpack中使用。

2.4 框架应该输出怎么样的构建产物

        根据不同的需求背景Vue.js会输出不同的产物，比如在HTML页面中使用<script>标签引入框架
    并使用：

        <body>
            <script src='/path/to/vue.js'></script>
        </body>

        为了实现这个需求，需要输出IIFE格式的资源。IIFE即“立即调用的函数表达式”，用JS来表达：

        1. (function() {
        2.     //
        3. }())

        在Vue.global.js文件中的IIFE形式的资源，代码结构如：

        1. var Vue = (function(exports){
        2.     //...
        3.     exports.createApp = createApp;
        4.     //...
        5.     return exports
        6. })

        这样使用<script>标签直接引入Vue.global.js文件后，全局变量Vue就是可用的了。

        在rollup.js中，可以通过配置format： 'iife'来输出这种形式的资源：

        1. //rollup.config.js
        2. const config = {
        3.     input：'input.js',
        4.     output: {
        5.         file: 'output.js',
        6.         format: 'iife' //指定模块形式
        7.     }
        8. }
        9. 
        10.  export default config

        随着技术的发展和浏览器的支持，现在主流浏览器对原生ESM的支持都不错，因此可以直接引入ESM
    格式的资源，在Vue.js3中会输出vue.esm-browser.js文件，可以直接用<script type='module'>
    标签引入：

        <script type='module' src='/path/to/vue.esm-browser.js'></script>

        rollup.config.js中配置format: 'esm'就可以输出ESM格式资源。

        Vue.js除了会输出一个vue.esm-browser.js的ESM格式文件外，还会输出另一个ESM格式的文件
    vue.esm-bundler.js文件，因为无论是rollup.js还是webpack，在寻找资源时，如果package.json
    中有module字段，那么会优先使用module字段指向的资源来代替main字段指向的资源。如Vue.js源码
    中的package/vue/package.json文件:

        1. {
        2.     "main": "index.js",
        3.     "module": "dist/vue.runtime.esm.bundler.js"
        4. }

        从这可以看出使用webpack构建,那么Vue.js资源就是vue.runtime.esm.bundler.js,就是说带
    有-bundler字样的就是ESM资源给rollup.js或webpack等打包工具使用的,而-browser字样的是给
    <script type='module'>使用的。

        它们之间的区别在于,__DEV__常量,当构建用于生产环境时,__DEV__常量会设置为false,从而触
    发Tree-Shaking。但是使用打包工具打包ESM资源时,不能直接把__DEV__设置为true或false,而要使
    用(process.env.NODE_ENV !== 'production')替换__DEV__常量。例如Vue源码:

        1. if(__DEV__){...}

        带有-bundler字样的资源中会变成:

        1. if(process.env.NODE_ENV !== 'production'){...}

        这样使用webpack配置自行决定构建资源的目标环境,但是最终效果其实一样,这段代码只会出现在
    开发环境中。

        除了用<script>标签引入资源外,还可以使用Node.js中通过require语句引用资源

        1. const Vue = require('vue')

        这可以用于服务器渲染,当进行服务器渲染时,Vue.js的代码是在服务器端运行的，而非浏览器环境
    Node.js是使用CommonJS，为了能输出cjs模块资源，可以在Vue.global.js中配置format: 'cjs'来
    实现。

2.5 特性开关

        设计框架时，框架会给用户提供很多种特性，例如提供A、B、C三种特性，那么同时就需要提供对
    应的a、b、c三种特性开关，用户可以根据需求设置a、b、c三种特性开关true或false开启相应的特性。

        对于用户关闭的特性，可以利用Tree-Shaking机制让其不在最终打包产物中。

        该机制可以为框架设计带来了灵活性，可以通过特性开关任意为框架添加新特性，而不用担心最终
    产物资源体积变大。同时，当框架升级时，也可以通过特性开关来支持遗留API，这样新用户可以选择
    不适用遗留API，从而使最终打包出来的资源体积最小化。

        实现特性开关其实很简单，原理和上文提到的__DEV__常量一样，本质就是利用rollup.js的预定
    义常量插件来实现。如Vue.js3源码：

        1. {
        2.     __FEATURE_OPTIONS_API__: isBundlerESMBuild ? `__VUE_OPTIONS_API__`: true,
        3. }

        其中__FEATURE_OPTIONS_API__就类似__DEV__常量。在Vue.js3源码中可以找到很多类似的代码分
    支：

        1. if(__FEATURE_OPTIONS_API__) {...}

        在构建资源时，如果构建的资源时供打包工具使用的（上文中带有-bundler的资源），上面的代码会
    变成：

        1. if(__VUE_OPTIONS_API__) {...}

        __VUE_OPTIONS_API__就是一个特性开关，用户可以通过设置它预定义常量的值来控制是否保留这段
    代码。在webpack中可以通过webpack.DefinePlugin插件来设置：

        1. new webpack.DefinePlugin({
        2.     __VUE_OPTIONS_API__: JSON.stringify(true) //开启特性
        3. })
   
        __VUE_OPTIONS_API__在Vue.js中的作用是，在Vue.js2中，编写的组件叫作组件选项API：

        1. export default {
        2.     data() {}, //data选项
        3.     computed: {}, //computed选项
        4.     //其他选项
        5. }

        但是在Vue.js3中，推荐使用的是Composition API来编写代码， 例如：

        1. export default {
        2.     setup() {
        3.         const count = ref(0)
        4.         //相当于Vue.js2中的computed选项
        5.         const doubleCount = computed(() => count.value * 2)
        6.     }, 
        7. }

        为了Vue.js3中为了兼容Vue.js2的选项API，用户可以根据需求来设置__VUE_OPTIONS_API__使不
    使用，确定不使用时可以关闭该特性，达到减小最终打包资源的体积。

2.6 错误处理

        错误处理是框架开发过程中一个非常重要的环节，错误处理的好坏直接决定了用户应用程序健壮性，
    还能决定用户开发时错误处理的心智负担。

        用户代码执行出错了，第一个方法时自行处理，需要自己执行try...catch,导入utils,调用
    utils里的foo函数,例如：

        1. import utils form 'utils.js'
        2. utils.foo(() => {
        3.     try{//...} catch(e){//...}  
        4. })
   
        如果utils.js中不只有一个foo函数,而是提供了几十上百个这样的函数,用户需要每个函数都添加
    错误处理。

        第二个方法时我们代替用户统一处理错误，将错误处理程序封装为一个函数，假设定义一个函数
    callWithErrorHandling：

        1. // utils.js
        2. export default {
        3.     foo(fn) {
        4.         callWithErrorHandling(fn)
        5.     }
        6.     bar(fn) {
        7.         callWithErrorHandling(fn)
        8.     }
        9. }
        10. function callWithErrorHandling(fn) {
        11.    try{
        12.        fn && fn()
        13.    } catch (e) {
        14.        console.log(e)
        15.    }
        16.  }

        这样的好处不仅代码变得简洁明了，最重要的是可以为用户提供统一的错误处理接口。

        上面的代码还可以进一步优化，可以提供一个统一注册错误处理的函数，注册后可以捕获到错误再传
    给用户，这样可以提高灵活性。如：

        1. // utils.js
        2. // 错误处理程序
        3. let handleError = null
        4. export default {
        5.     foo(fn) {
        6.         callWithErrorHandling(fn)
        7.     }
        8.     // 用户可以调用该函数注册统一的错误处理函数
        9.     registerErrorHandling(fn) {
        10.        handleError = fn
        11.    }
        12. }
        13. function callWithErrorHandling(fn) {
        14.    try{
        15.        fn && fn()
        16.    } catch (e) {
        17.    // 将捕获到的错误传递给用户的错误处理程序
        18.        handleError(e)
        19.    }
        20.  }

        1.  //调用函数
        2.  import utils form 'utils.js'
        3.  // 注册错误处理程序
        4.  utils.registerErrorHandling(e => {
        5.      //用户自定义的错误处理
        6.  })
        7.  utils.foo(() =>{...})

        其实也是Vue.js的错误处理原理，源码中可以搜索callWithErrorHandling函数。另外，在Vue.js
    中也可以注册统一的错误处理函数：

        1. import App from 'App.vue'
        2. const app = createApp(App)
        3. app.config.errorHandler = () =>{
        4.     //用户自定义的错误处理
        5. }