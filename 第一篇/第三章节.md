Vue.js3的设计思路

3.1 声明式地描述UI

        Vue.js3是一个声明式的框架，也就是使用声明式地描述UI的，设计声明式框架前先了解下编写前端
    页面设计哪些内容：

        1. DOM元素： 例如div标签、a标签等元素标签。
        2. 属性： 例如a标签上的href、标签上的id、class等。
        3. 事件： 例如click、keydown等。
        4. 元素的层级结构： DOM树的层级结构、既有子节点又有父节点。

        Vue.js3描述上述内容的方案是：

        1. 使用与HTML标签一致的方式描述DOM元素：如描述div标签直接<div></div>。
        2. 使用与HTML标签一致的方式描述标签的属性： 如div标签中的id<div id='div'></div>。
        3. 使用v-bind或:描述动态绑定属性： 如div标签中的动态id<div :id='div'></div>或
            <div v-bind:id='div'></div>。
        4. 使用v-on或@来描述事件：例如描述点击事件<div @click='handler'></div>或
            <div v-on:click='handler'></div>。
        5. 使用与HTML标签一致的方式描述层级结构： 如div包含一个span子节点<div><span></span></div>。

        从上述中知道在Vue中DOM元素、属性、事件等都有相应的描述方式，不需要用户手写命令式代码，这
    就是声明式地描述UI

        除了使用上述地模板(组件中的<template>写法)来声明式地描述UI外，还可以使用JS对象描述，将
    <div v-on:click='handler'><span></span></div>用JS对象描述如：

        1. const title = {
        2.     // 标签名称
        3.     tag: 'h1',
        4.     // 标签属性
        5.     props: {
        6.         onClick: handler
        7.     },
        8.     // 子节点
        9.     children: {
        10.        {tag: 'span'}
        11.    }
        12. }

        使用JS对象描述UI的好处就是更灵活，假如描述一个h1-h6的标标签，用JS对象描述如：

        1. //h标签的等级
        2. let level = 3
        3. const title = {
        4.     tag: `h${level}`
        5. }

        使用JS对象描述可以更改level来改变h标签。

        使用模板描述就需要依次手HTML代码如：
        1. <h1 v-if="level === 1"></h1>
        2. <h2 v-else-if="level === 2"></h2>
        3. <h3 v-else-if="level === 3"></h3>
        4. <h4 v-else-if="level === 4"></h4>
        5. <h5 v-else-if="level === 5"></h5>
        6. <h6 v-else-if="level === 6"></h6>

        可以看到模板描述远不如JS对象描述灵活，使用JS对象描述，就是所谓的虚拟DOM，也就是因为虚拟
    DOM的灵活性，Vue除了支持模板描述UI外，同时也支持虚拟DOM描述UI。

        平时组件中手写的渲染函数就是使用虚拟DOM描述UI，如下代码：

        1. import { h } from 'vue'
        2. export default {
        3.     render() {
        4.         return h('h1', {onClick: handler}) //虚拟DOM
        5.     }
        6. }

        上述的h函数是辅助创建虚拟DOM的一个工具函数，调用后会返回一个对象，这个对象就是虚拟DOM。

3.2 初识渲染器

        虚拟DOM的本质就是一个使用JS对象描述的真实DOM结构，虚拟DOM变成真实的DOM则需要通过渲染器。

        渲染器的作用就是将虚拟DOM渲染为真实DOM，过程如：

        1. h('h1', {onClick: handler})(虚拟DOM) ---> 渲染器 ---> 真实DOM

        实现一个简易的渲染器，如：
        1. function renderer (vnode, container) {
        2.     // 使用vonde.tag作为标签名创建元素
        3.     const el = document.createElement(vnode.tag)
        4.     // 循环遍历vonde.props，将属性、事件添加到标签元素中
        5.     for (const key in vnode.props) {
        6.         //判断是否为事件
        7.         if(/^on/.test(key)) {
        8.             el.addEventListener(
        9.                 // 事件名称，如onClick --->click
        10.                 key.substring(2).toLowerCase(),
        11.                 // 处理事件
        12.                 vnode.props[key]
        13.             )
        14.         }
        15.     }
        16.     //处理children
        17.     if(typeof vnode.children === 'string') {
        18.         // 如果children是字符串，说明它是元素的文本节点
        19.         el.appendChild(document.createTextNode(vnode.children))
        20.     }else if(Array.isArray(vnode.children)){
        21.         // 如果是数组，说明有子节点，递归调用函数渲染子节点,使用el作为挂载点
        22.         vnode.children.forEach(child => renderer(child, el));        
        23.     }
        24.     //最后将元素添加到挂载节点中
        25.     container.appendChild(el)
        26. }

        再构造一个虚拟DOM：

        1. const vnode = {
        2.     tag: 'div',
        3.     props: {
        4.         onClick: () =>alert('hello')
        5.     },
        6.     children: 'click me'
        7. }
        8. // 调用renderer函数
        9. renderer(vnode, document.body) //将body作为挂载点

        一个简易的渲染器renderer的实现思路，总体分为三步：

        1. 创建元素：将tag作为元素名创建元素
        2. 给元素添加事件或属性：遍历props再进行判断，如果on开头的说明是事件，使用addEventListener
            绑定到元素中，注意将'on'截去再用toLowerCase转化为小写字符串。
        3. 处理处理children：如果是字符串，直接新创建文本插入标签元素，如果是数组则循环递归调用
            renderer，注意将刚刚的标签元素当成挂载点。

3.3 组件的本质

        组件也可以使用虚拟DOM来描述，它并不是真实的DOM元素，组件的本质其实就是一组DOM元素的封装，如：

        1. const MyComponent = function() {
        2.    return {
        3.        tag: 'div',
        4.        props: {
        5.            onClick: () => alert('hello')
        6.        },
        7.        children: 'click me'
        8.    }
        9. }

        定义了一个名为MyComponent的函数，函数返回一个对象，该对象就是一个虚拟DOM，可以该函数作为
    tag，传到renderer函数里，如：

        1. const vnode = {
        2.     tag: 'MyComponent'
        3. }
        
        为了渲染组件需要对前面的renderer函数做修改，如：

        1. function renderer(vnode, container) {
        2.     if(typeof vnode.tag === 'string') {
        3.         //如果vnode.tag为字符串，说明描述的是标签元素
        4.         mountElement(vnode, container)
        5.     }else if(typeof vnode.tag === 'function'){
        6.         //如果vnode.tag为函数，说明描述的是组件
        7.         mountComponent(vnode, container)
        8.     }
        9. }

        其中mountElement函数就是上个章节的渲染器renderer函数，mountComponent函数的实现如下：

        1. function mountComponent(vnode, container) {
        2.     //vnode.tag是函数，所有执行函数拿到返回的虚拟DOM
        3.     const subtree = vnode.tag()
        4.     //递归调用渲染器渲染subtree
        5.     renderer(subtree, container)
        6. }

        因为是用将虚拟DOM对象封装到一个函数中，因此vnode.tag将是个函数，将函数执行拿到虚拟DOM，然后
    再递归渲染subtree。

        其实组件不一定得是函数，也可以是一个对象：

        1. const MyComponent = {
        2.    render() {
        3.      ...  //虚拟DOM对象
        4.    }
        5. }

        这里使用了一个对象代表组件，该对象有一个函数render，它会返回需要渲染内容的虚拟DOM，为了适配对
    象类型的组件，需要对渲染器进行调整。

        1. //在renderer函数中将typeof vnode.tag === 'function'改为
        2. if(typeof vnode.tag === 'object')
        3. //
        4. //在mountComponent函数中将const subtree = vnode.tag()该为const subtree = vnode.tag.render()
        5. const subtree = vnode.tag.render()

        其实可以将组件的本质当作比较复杂的虚拟DOM，无论是将组件封装成什么形式的，只要能能拿到该虚拟
    DOM然后将它放入渲染器中即可。
