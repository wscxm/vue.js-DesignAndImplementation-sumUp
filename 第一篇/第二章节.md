第二章节 框架设计的核心要素

2.1 提升用户开发体验

        在设计框架时，合理的警告信息，可以让用户快速定位到问题的所在，进而进行修改，这可以给用
    户带来更好的开发体验。比如：

        1. createApp(App).mount('#not-exist')

        当创建一个Vue.js应用并试图挂载在不存在的DOM节点时，会收到一条警告，该信息会告诉我们挂
    载失败了，并且说明了Vue.js根据我们提供的选择器无法找到相应的DOM元素。这条信息可以让我们很
    快就定位到了问题所在。所以框架设计过程中，友好的警告信息至关重要。

        在Vue.js源码中，可以看到经常调用warn函数.如提醒找不到挂载的目标DOM元素警告:

        1. warn(`Failed to mount app: mount target selector "${container}" returned null`)

        对于warn函数来说，由于需要尽可能提供有用信息，因此需要收集当前发生错误的组件栈信息，源
    码中会有些复杂，但是最终就是调用了console.warn函数。

        在Vue3中除了必要的警告信息外，还有许多提升用户开发体验的点。例如，在控制台打印一个ref
    数据：

        1. const count = ref(0)
        2. console.log(count)

        在控制台中会输出一个RefImpl的对象，打印的数据非常不直观。在Vue3的源码中，可以搜索
    initCustomFormatter的函数，该函数可以在开发环境下初始化自定义formatter。以Chrome为例，
    可以打开DevTools的设置，勾选“Console”中的“Enable custom formatter”选项，然后刷新浏览器
    就可以看到控制台输出的内容变得非常直观。

2.2 控制框架代码的体积

        框架的大小也是衡量框架的标准之一。实现同样功能情况下，代码越少越好，这样体积就会越小，
    浏览器加载资源的时间也会越少。

        在Vue.js中提供越完善的警告提示就意味着代码量的增加，Vue3源码中，每个warn函数的调用都
    会配合__DEV__常量的检查。例如：

        1. if (__DEV__ && !res) {
            warn(`Failed to mount app: mount target selector "${container}" returned null`)
        }

        打印警告的信息前提就是__DEV__常量必须为true才行。

        Vue.js使用rollup.js对项目进行构建,这里的__DEV__是通过rollup.js的插件配置来预定义的
    其功能类似于webpack的DefinePlugin插件。

        Vue.js输出资源时会有两个版本，其中一个用于开发环境，如vue.globel.js,另一个版本用于生
    产环境,如vue.globel.prod.js。

        当Vue.js构建用于开发环境资源时,会把__DEV__常量预设为true,这时警告信息在开发环境肯定
    存在的。在生产环境时__DEV__常量预设为false,这样警告信息就不会执行,不会出现在最终产物中,
    在构建资源时会被移除。

        这样就可以做到在开发环境中提供友好的警告信息的同时,不会在增加生产环境代码的体积。

2.3 框架要做到良好的Tree-Shaking

        Tree-Shaking这个概念因rollup.js而普及，指的的是消除那些永远不会被执行的代码，也就是
    排除dead code。

        想要实现Tree-Shaking，必须要满足一个条件，即模块必须是ESM（ES Module），因为
    Tree-Shaking依赖ESM的静态结构。

        假设有两个文件input.js和utils.js，它们的内容是：
        
        //input.js
        1. import { foo } from 'utils.js' 
        2. foo()
        //utils.js
        3. export function foo(obj) {
        4.     obj && obj.foo
        5. }
        6. export function bar(obj) {
        7.     obj && obj.bar
        8. }

        npx rollup input.js -f esm -o bundle.js

        在input.js中引入utils.js的foo函数并执行，然后进行构建并输出一个bundle.js，可以看到他
    的内容：

        1. function foo(obj) {
        2.     obj && obj.foo
        3. }
        4. foo();

        可以看到,内容中并没有将bar函数打包进来，这说明Tree-Shaking起到了作用，将没有使用的
    bar函数作为dead code删除了。

        代码中的foo()是执行foo函数，它仅仅是读取了对象的值，在代码中并没有什么必要，但是
    rollup.js并没有将它当作dead code删除，这是因为涉及到了Tree-Shaking的第二个关键点--副作用
    如果一个函数的调用会产生副作用， 那么就不能将其移除。

        副作用就是当调用函数的时候会对外部产生影响，例如：修改了全局变量。

        上面的代码因为是读取对象的值，如果obj对象是通过Proxy创建的对象，当读取对象属性时，就会
    触发代理对象的get夹子(trap)，在get夹子中可能会产生副作用。但是到底会不会产生副作用啊，只有
    在代码真正运行时才知道，JS本身时动态语言，因此想要静态分析哪些代码是dead code很有难度，因
    此上面只是举例一个简单的例子。

        因为静态分析JS代码有困难，所以像rollup.js这类构建工具都会提供一个机制，让我们手动声明
    该代码没有副作用，可以放心进行Tree-Shaking，如：

         //input.js
        1. import { foo } from 'utils.js' 
        2. /*#__PURE__*/ foo()

        在代码前添加/*#__PURE__*/就是声明该代码不会产生副作用，可以进行Tree-Shaking。

        在Vue3的源码中就使用了大量的/*#__PURE__*/，例如：

        1. export const isHTMLtag = /*#__PURE__*/ makeMap(HTML_TAGS)

        在Vue3源码中多数都是在顶级函数(函数外的调用)中添加/*#__PURE__*/注解，因为函数内的调
    用如果该函数没被调用就不会产生副作用。例如：

        1. foo() //顶级调用
        2. function bar() {
            foo() //函数内调用
        }

        /*#__PURE__*/注解不止可以在rollup.js中使用，还可以在webpack中使用。


   