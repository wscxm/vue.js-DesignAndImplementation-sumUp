# 第四章 响应式系统的作用与实现

### 4.1 响应式数据与副作用函数 

        //全局变量
        let val = 1
        function effect() {
            val = 2 //修改全局变量
        }

        副作用就是值会产生副作用的函数，如上面代码中，val是一个全局变量，有可能会在多个地方用到，
    effect函数中修改了val，那么其他引用到val的地方可能就会直接或间接收到影响。影响到其他地方
    就是effect产生了副作用。

        响应式数据就是当数据发生变化后，副作用函数自动会重新执行。

        const obj = {text: 'hello world'}
        function effect() {
            document.body.innerText = obj.text
        }
        
        如上面的代码，如果obj.text的值发生了改变，那么副作用函数effect自动会重新执行，obj就被
    称为响应式数据。

### 4.2 响应式数据的基本实现

        变成响应式数据，可以有两个步骤：
        
        1. 当副作用函数(上文的effect())执行时，会触发副作用内数据的读取操作；
        2. 当修改数据时，会触发数据的设置操作

        可以看出想要实现响应式需要先拦截对象的读取和设置操作，可以使用一个“桶”当容器，将副作用函数存储
    起来。

        读取操作：

        执行副作用函数(effect())  ---> 触发读取操作 ---> 将副作用函数存储容器“桶”中

        设置操作：

        容器“桶” ---> 触发设置操作 ---> 拿出并执行副作用函数(effect())

        可以看出读取操作就是将副作用函数存储到容器中，设置操作就是将副作用函数从容器中拿出来执行。

        在Vue2中使用的是Object.defineProperty函数对对象进行拦截，到Vue3时使用了ES6中的代理对象
    Proxy来实现,如下时一个简单的代理实现对对象的拦截：

        // 存储副作用函数的桶
        const bucket = new Set()
        // 原始数据
        const data = { text: 'hello world' }
        // 对原始数据的代理
        const obj = new Proxy(data, {
            // 拦截读取操作
            get(target, key) {
                // 将副作用函数添加到存储到存储副作用函数的桶中
                bucket.add(effect)
                // 返回属性值
                return target[key]
            },
            // 拦截设置操作
            set(target, key, newVal) {
                // 设置属性值
                target[key] = newVal
                // 把副作用函数从桶中取出并执行
                bucket.forEach(fn =>fn())
                //返回 true 代表操作成功
                return true
            }
        })

        //副作用函数
        function effect() {
            document.body.innerHTML = obj.text
        }

        //执行副作用函数触发读取
        effect()
        //一秒后修改响应式数据
        setTimeout(() => {
            obj.text = 'hello vue3'
        },1000)

        上面的代码就可以实现一个简单的对象拦截来实现响应式数据。

### 4.3 设计一个完善的响应式系统

        前面实现的响应式系统中存在这许多的缺陷，比如，副作用函数是写死的，如果改变了副作用名称那就找不
    到函数。想要解决这个缺陷可以使用一个全局变量存储被注册的副作用函数

        // 用一个全局变量存储被注册的副作用函数
        let activeEffect 
        // effect 函数用于注册副作用函数
        function effect(fn) {
            //调用effect注册副作用函数时，将副作用函数fn赋值给activeEffect
            activeEffect = fn
            //执行注册副作用函数
            fn()
        }

        将用effect函数当作用来注册副作用函数的注册器，将副作用函数当作参数，当执行注册器时，将副作用
    函数存储到全局变量中并执行副作用函数，这样无论副作用函数名称是什么，只要当成参数传入注册器都可以
    发挥副作用函数的作用，这样不用依赖副作用函数名，提高了灵活性。

        修改代理对象proxy中get拦截函数：

        get(target, key) {
            //将activeEffect中存储的副作用函数收集到“桶”中
            if(activeEffect) {
                bucket.add(activeEffect)
            }
            // 返回属性值
            return target[key]
        }

        副作用函数是写死的，不灵活只是其中一个缺陷，下面来看另一个缺陷，假如给一个对象obj中的属性text
    读取操作后再给obj对象中添加一个新属性。如下：

        //副作用函数
        () => {
            console.log('a') //执行两次
            document.body.innerHTML = obj.text
        }

        //给obj对象中添加一个新属性
        obj.notExist = 'hello vue3'

        可以看到打印了两次字符串'a'，说明在给obj对象中添加一个新属性时，触发了set拦截，再次执行了副作
    用函数，但是正确的是应该是obj.text被设置时才触发set拦截执行副作用函数。

        这个问题是因为没有在副作用函数与被操作的目标字段之间建立明确的联系。当读取属性时，无论是读取对
    象的哪个属性都会把副作用函数收集到容器“桶”中，设置也是无论设置哪个都会从容器“桶”中拿出副作用函数执
    行。

        需要解决这个问题的方法就是将副作用函数与被操作的字段之间建立联系，这需要重新设计容器“桶”的数据
    结构，不能简单的使用Set类型数据。

        effect(function effectFn() {
            document.body.innerHTML = obj.text
        })

        上面的代码中存在三种角色：

        1. 被读取操作的代理对象obj；
        2. 被读取操作的属性text；
        3. 副作用函数effectFn；

        需要给它们设计的结构是树型的结构

        target
            |__ key(属性名)
                 |__ effectFn

        这就是它们的对应关系，简单描述就是可以在target中找到key，target[key]可以找到effectFn。

        如果是两个副作用函数同时读取同一个对象属性：

        effect(function effectFn1() {
            document.body.innerHTML = obj.text
        })
        effect(function effectFn2() {
            document.body.innerHTML = obj.text
        })
        //对应的关系
        target
            |__ text(属性名)
                 |__ effectFn1
                 |__ effectFn2

        如果一个副作用函数读取了一个对象中两个不同属性：

        effect(function effectFn() {
            obj.text
            obj.text1
        })
        //对应的关系
        target
            |__ text(属性名)
                 |__ effectFn

            |__ text1(属性名)
                 |__ effectFn

        这样就建立关系后就可以解决上面的问题了，如设置了obj.text，那么就会拿到obj.text中对应
    的副作用函数执行。

        将之前的拦截器代码进行进一步的修改，修改其中的“桶”结构，让它们能够建立关联关系,构建
    “桶”的结构使用到了 WebMap、Map、Set：

        1. WebMap由target ---> Map构成
        2. Map由key ---> Set构成

        const obj = new Proxy(data, {
            // 拦截读取操作
            get(target, key) {
                // 如果没有全局变量activeEffect，直接return出去
                if(!activeEffect) return
                // 根据target从“桶”bucket中拿到depsMap，它也是一个Map类型：key ---> effects
                // depsMap是被代理的数据下的所有属性中所有对应的副作用函数的一个集合
                let depsMap = bucket.get(target)
                // 如果不存在depsMap，那么新建一个Map并与target关联
                if(!depsMap) {
                    bucket.set(target, (depsMap = new Map()))
                }
                // 再根据key从depsMap中取出deps，它是一个Set类型
                // deps里面存储着当前所有与key相关的副作用函数
                let deps = depsMap.get(key)
                // 如果deps不存在，同样新建一个Set并与key关联
                if(!deps) {
                    depsMap.set(key, (deps = new Set()))
                }
                // 前面做的都是要拿到“桶”deps，如过没有就重新构建一个
                // 最后将当前激活的副作用函数添加到“桶”中
                deps.add(activeEffect)
                // 返回属性值
                return target[key]
            },

            set(target, key, newVal) {
                // 设置属性值
                target[key] = newVal
                // 根据target从桶中拿到depsMap,如果没有就return出去
                const depsMap = bucket.get(target)
                if(!depsMap) return
                // 根据key拿到属性对应的关系列表再循环执行里面的副作用函数
                const effects = depsMap.get(key)
                effects && effects.forEach(fn => fn());
            }
        })

        其中WebMap的键是原始对象target，值是一个Map实例，而Map实例的键是原始对象target的key
    Map的值是由副作用函数组成的Set。

        WebMap和Map是有区别的，WebMap对key是弱引用，当其中有key值不被使用(引用)就会被垃圾回
    收机制回收。所以经常被用于存储只有当key被引用的对象存在时才有价值的信息。而Map就算key不被
    引用了，key也不会被回收，这可能会导致内存泄露。

        上面的代码可以进行优化，进行逻辑的拆分，将收集副作用函数到“桶”中的逻辑抽离，再将触发
    副作用函数的逻辑抽离。

        const obj = new Proxy(data, {
            // 拦截读取操作
            get(target, key) {
                track(target, key)
                // 返回属性值
                return target[key]
            },

            set(target, key, newVal) {
                // 设置属性值
                target[key] = newVal
                trigger(target, key)
            }
        })

        function track(target, key) {
            //...
        }

        function trigger(target, key) {
        //...
        }

        这样可以让代码的逻辑更加清晰，方便日后维护，也更加灵活。

### 4.4 分支切换与cleanup

        在副作用函数中如果读取操作存在分支切换，也就是读取操作根据状态变化执行的代码
    分支也变化，这就是分支切换。

        const data = {ok: true, text: 'hello world'}
        const obj = new Proxy(data, {/*...*/})

        effect(function effectFn() {
            document.body.innerHTML = obj.ok ? obj.text: 'not'
        })

        上面代码会根据obj.ok的变化切换代码分支。

        分支切换可能会产生遗留的副作用函数，如上面代码中触发读取操作的的属性由obj.ok
    和obj.text，它们两个都会和effectFn建立关系。

        data
          |__ ok(属性名)
               |__ effectFn  
          |__ text(属性名)
               |__ effectFn

        当它们其中一个发生设置操作都会执行同一个effectFn副作用函数，但是ok设置为false
    时，是不会走text分支的，但是obj.text的设置操作还是会执行effectFn副作用函数，这是
    多余的操作，也就是遗留的副作用函数导致的。

        准确的应该是当ok为false时，不会收集text的依赖集合，这样就不会在obj.text的设置
    操作时产生遗留副作用函数了。

        解决这个问题可以在每次执行副作用函数时，先将它从所有与之关联的依赖集合中删除，
    当副作用函数执行完后，会重新建立联系，但是新的联系中不会包含遗留的副作用函数。

        要将一个副作用函数从所有与之关联的依赖集合中移除，需要明确知道哪些依赖集合中包
    含它，因此需要重新设计副作用函数。

        let activeEffect 
        function effect(fn) {
            const effectFn = () => {
                // 将effectFn执行时，将其设置为当前激活的副作用函数
                activeEffect = effectFn
                fn()
            }
            // effectFn.deps(activeEffect.deps)用来存储所有与该副作用函数相关联的依赖集合
            effectFn.deps = []
            //执行副作用函数
            effectFn()         
        }

        收集effectFn.deps中的依赖集合是在track中：

            function track(target, key) {
                ... // 与上文的相同

                // deps就是一个与当前副作用函数存在联系的依赖集合
                // 将其添加到activeEffect.deps数组中
                activeEffect.deps.push(deps)
            }

        有了联系后，每次执行副作用函数时，根据effectFn.deps(activeEffect.deps)获取
    相关的依赖集合，进而将之移除。

        let activeEffect 
        function effect(fn) {
            const effectFn = () => {
                // 调用cleanup函数完成清除工作
                cleanup(effectFn)
                activeEffect = effectFn
                fn()
            }
            effectFn.deps = []
            effectFn()         
        }

        function cleanup(effectFn) {
            // 遍历effectFn.deps(activeEffect.deps)数组
            for(let i = 0; i < effectFn.deps.length; i++) {
                // deps是依赖集合
                const deps = effectFn.deps[i]
                // 将effectFn从依赖集合中移除
                deps.delete(effectFn)
            }
            // 重置effectFn.deps数组
            effectFn.deps.length = 0
        }

        这样就不会由遗留的副作用产生了，但是上面的代码会导致无限循环执行，这是因为在trigger
    函数中的：

        effects && effects.forEach(fn => fn()); //问题出现代码

        因为effects是个Set集合，在遍历执行时会调用cleanup进行清除当前副作用函数，但是
    在执行副作用函数时又会重新收集到集合中，而此时effects循环还在进行中，这样将永远无
    法执行完effects集合。如下代码：

        const set = new Set([1])

        set.forEach(item => {
            set.delete(1)
            set.add(1)
        })

        上述中在forEach遍历的对象中对该对象进行增加删除操作，这个会影响forEach的执行
    会导致循环一直无法执行完。因此在日常写代码时最好不要在forEach中对该对象进行增删
    改。

        可以使用一个深度拷贝的形式再拷贝一份set数据，使用拷贝的数据进行forEach：

        const set = new Set([1])

        const newSet = new Set(set) //深拷贝
        newSet.forEach(item => {
            set.delete(1)
            set.add(1)
        })
        
        这样在循环中操作的就不是被循环的对象了，也就不会无限循环下去了。

        在trigger函数对使用上述的方法进行修改就可以避免无限循环了。

        const effectsToRun = new Set(effects) // 新增
        effectsToRun.forEach(fn => fn()); // 新增
        effects && effects.forEach(fn => fn()); //删除

### 4.5 嵌套的effect与effect栈

Vue的渲染函数实际上时在一个effect副作用函数中执行的，比如组件的渲染函数：
```
// Foo组件
const Foo = {
    render() {
        return /* ... */
    }
}
```
当组件发生嵌套时（如父子组件），就会发生effect的嵌套：
```
const Bar = {
    render() {/* ... */}
}
// Foo组件渲染了Bar组件
const Foo = {
    render() {
        return <Bar />
}

// 副作用函数
effect(() => {
    Foo.render()
    // 嵌套
    effect(() => {
        Bar.render()
    })
})

```
前面我们实现的响应式系统时不支持嵌套的，如果副作用函数(effect)不支持嵌套的话，就会照成如果 
有嵌套的副作用函数执行会出错。例如：
```
const data = {foo: true, bar: true}
const obj = new Proxy(data, {/*...*/}
let temp1, temp2
// effectFn1中嵌套了effectFn2
effect(function effectFn1() {
    console.log('effectFn1 执行');
    effect(function effectFn2() {
        console.log('effectFn2 执行')
        // obj.bar读取操作
        temp2 = obj.bar
    })
    // obj.foo读取操作
    temp1 = obj.foo
})
```
当修改obj.foo时会打印出一下代码
```
'effectFn1 执行'
'effectFn2 执行'
'effectFn2 执行'
```
一共打印了三次，前面两次是初始执行也就是注册副作用函数时打印的。第三次是修改obj.foo打印
的，这很明显执行出错了。

照成错误的其实是实现effect与activeEffect上，因为全局遍历activeEffect能存储的副作用函数只有一个
它表示当前激活的副作用函数，当有嵌套时，执行到内层副作用函数时activeEffect就会覆盖掉上层的
副作用函数，因此就算时有外层的副作用函数被触发依赖收集时收集得到的也是内层的。

这个问题可以使用一个栈来将嵌套的所有副作用函数都放进去，当执行副作用函数时就将副作用函数
压入栈中，只有执行完后才将其弹出，并始终让activeEffect指向栈顶的副作用函数，这样就可以让响应
式数据只会收集读取其值的副作用函数。
```
let activeEffect
// 存储栈
const effectStack = [
function effect(fn) {
    const effectFn = () => {
        cleanup(effectFn)
        activeEffect = effectFn
        // 在调用副作用函数前将当前副作用函数压入栈中
        effectStack.push(effectFn)
        fn()
        // 执行完毕后弹出栈
        effectStack.pop()
        // 将activeEffect指向栈顶，这样收集的依赖就是外层的，而不是内层的
        activeEffect = effectStack[effectStack.length - 1]
    }
    effectFn.deps = []
    effectFn()
}
```
如此一来响应式数据就只会收集直接读取其值的副作用函数作为依赖，从而避免错乱。

### 4.6 避免无限递归循环

如果在一个副作用函数中有一个自增操作，会造成无限递归循环，引起栈溢出。举个例子：
```
const data = { foo: 1 }
const obj = new Proxy(data, {/*...*/})
effect(() =>obj.foo++)

// 上面副作用函数代码可以看成
effect(() => {
    obj.foo = obj.foo + 1
})
```
可以看到副作用中进行了读取操作又设置操作，这会造成执行副作用函数中又触发了设置操作继续执行副
作用， 形成无限循环。

因为设置和读取都是在同一个副作用函数内进行，无论是收集副作用还是执行副作用，activeEffect都是
同一个函数，因此我们可以在trigger设置函数中增加守卫条件，**如果trigger触发执行的副作用与当前正在**
**执行的副作用函数相同，则不触发执行**
```
function trigger(target key) {
    // 省略部分代码
    // ...
    const effectsToRun = new Set(effects)
    effects && effects.forEach(effects => {
        if(effects !== activeEffect) {
            // 将不是当前正在执行的副作用函数添加到effectsToRun中
            effectsToRun.add(effects)
        }
    });
    effectsToRun.forEact(fn => fn())
}
```

### 4.7 调度执行

可调度性是响应式系统非常重要的特性，可调度就是指触发副作用函数重新执行时，可以决定副作用函数
调用时机、次数以及方式。

举个例子：
```
const data = {foo:1}
const obj =new Proxy(data,{})

effect(() => {
    console.log(obj.foo)
})

obj.foo++

console.log('结束了')
```
上面的代码正常的输出：
```
1
2
'结束了'
```
如果需要将输出的顺序调整为：
```
1
'结束了'
2
```
这需要响应式系统支持**调度**，因此可以设计一个调度器，调度器放入一个对象中，然后当成effect副作用
函数注册器的第二个参数传入。
```
effect(
    () => {
        console.log(obj.foo)
    },
    // 
    {
        // 调度器 scheduler 是一个函数
        scheduler(fn){//...}
    }
)
```
在effect的内部还需要将scheduler调度器挂载在对应的副作用函数上, options参数接收调度器对象。
```
effect(effectFn,, options){
    // 省略部分上文已有代码

    // 将options挂载在effectFn上
    effectFn.options = options // 新增
}
```
有了调度器后，将触发副作用函数的trigger函数修改为：
```
function trigger(target, key) {
    // 省略部分上文已有代码

    //修改部分
    effectsToRun.forEact(effectFn => {
        // 如果有调度器则调用调度器，将副作用函数传入
        if(effectFn.options.scheduler) {
            effectFn.options.scheduler(effectFn)
        } else {
            // 否则直接执行副作用函数
            effectFn()
        }
    })
}
```
设计完成后，可以实现前面的需求了，用户可以实现调度器控制如何执行，然后输出想要的打印顺序：
```
// 调度器的实现
effect(
    () => {
        console.log(obj.foo)
    },
    // 
    {
        // 调度器 scheduler 是一个函数
        scheduler(fn){
            // 将副作用函数放到宏任务中
            setTimeout(fn)
        }
    }
)
```
除了控制副作用的执行顺序，还可以控制执行次数：
```
const data = {foo:1}
const obj =new Proxy(data,{})

effect(() => {
    console.log(obj.foo)
})

obj.foo++
obj.foo++
```
上面代码会输出：
```
1
2
3
// 希望输出
1
2
```
基于调度器，可以这样实现此功能：
```
// 定义一个Set数据结构的对象，作为任务队列
const jobQueue = new Set()
// 使用Promise.resolve 创建实例，可以将任务加入微任务队列
const p = Promise.resolve()
// 定义一个标志符代表是否正在刷新队列
let isFlushing = false
function flushJob() {
    // 如果正在刷新队列，则退出函数，不执行任务队列
    if (isFlushing) return
    //  设置为true，表示正在刷新
    isFlushing = true
    // 在微任务队列中刷新任务队列
    p.then(() => {
        jobQueue.forEach(job => job())
    }).finally(() => {
        // 结束后重置isFlushing
        isFlushing = false
    })
}

effect(
    () => {
        console.log(obj.foo)
    },
    // 
    {
        scheduler(fn){
            // 每次调度时，将副作用函数添加到任务队列中
            jobQueue.add(fn)
            // 调用flushJob刷新队列
            flushJob()
        }
    }
)

obj.foo++
obj.foo++
```
obj.foo执行两次自增会连续两次执行scheduler调度函数，jobQueue.add也会执行两次，但是Set数据结构有去
重的能力，因此只会保留一项相同的副作用函数。flushJob也相应的会执行两次，但是isFlushing的存在，因
此flushJob在一个事件循环内也只会执行一次。由于jobQueue中只有一个副作用函数，因此只会执行一次。

这个功能的思路与Vue中连续多次修改响应式数据但是只触发一次更新的思路是一样的，但是Vue中的调度器
实现更加完善。




